# HTML相关面试题整理

## HTML语义化标签的优点

* 便于用户阅读，样式丢失的时候能让页面呈现清晰的结构
* 有利于SEO（搜索引擎优化），搜索引擎根据标签来确定上下人和各个关键字的权重，利于浏览器爬虫
* 方便其他设备解析，如盲人阅读器根据语义渲染网页
* 便于团队开发和维护，更具可读性

## 页面渲染流程

* 浏览器解析html源码，然后创建一个 DOM树。在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。

	**DOM树的根节点就是documentElement，对应的是html标签。**

* 浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。
  对CSS代码中非法的语法它会直接忽略掉。
  
* 解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html中的style。

	**DOM Tree + CSSOM --> 渲染树（rendering tree）。**

* 渲染树和DOM树有点像，但是是有区别的。DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。

  需要注意的是，渲染树(Render Tree)由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。

**三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。**

一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。

## http和https的区别

https的SSL加密是在传输层实现的。

(1)http和https的基本概念

http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。

### http和https的区别

* Https协议需要ca证书，费用较高。

* http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

* 使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443

* http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### https协议的工作原理

客户使用https url访问服务器，则要求web 服务器建立ssl链接。

web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。

客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。

客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。

web服务器通过自己的私钥解密出会话密钥。

web服务器通过会话密钥加密与客户端之间的通信。

### https协议的优点

使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

### https协议的缺点

https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。

https缓存不如http高效，会增加数据开销。

SSL证书也需要钱，功能越强大的证书费用越高。

SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。

##	TCP 三次握手，四次挥手

<img :src="$withBase('/img/三报文握手.png')" alt="three-way-handshake"/>

> 下面介绍三报文握手的过程，其中用 A 表示TCP客户程序，B表示TCP服务器程序。
>
> * 最开始，A、B：CLOSED（关闭）状态，A、B都创建传输控制块TCB。
> * 第一个：A向B发送 连接请求报文段（同步位SYN=1，不能携带数据，初始序号 seq=x）；
> * A发送后：SYN-SENT（同步已发送）状态；B：LISTEN（收听）状态。
> * 第二个：B向A发送 确认报文段（SYN=1，ACK=1，确认号ack=x+1，不能携带数据，初始序号 seq=y）；
>   B收到并发送后：SYN-RCVD（同步收到）状态。
> * 第三个：A向B发送 确认报文段（ACK=1，ack=y+1，序号seq=x+1，携带数据消耗序号，不携带不消耗）；
> * A收到并发送后：ESTAB-LISHED（已建立连接）状态。
> * B收到后：ESTAB-LISHED（已建立连接）状态。

#### 为什么A最后还要发送一次确认？

主要是为了防止**已失效的连接请求报文段**（A向B发送的第一个报文段延误到连接释放以后的某个时间）突然又传送到了B，让B误以为A又发出了一次新的连接请求，因而产生错误。



### 四报文挥手

TCP的连接释放又称为**四报文握手**，客户和服务器之间需要交换**四个 TCP 报文段**。

> * 最开始，A、B：ESTAB-LISHED（已建立连接）状态。
> * 第一个：A向B发送 连接释放报文段（终止控制位FIN=1，序号seq=u，u是A已传送的最后一个字节的序号 + 1）；
> * A发送后：FIN-WAIT-1（终止等待 1）状态。
> * 第二个：B向A发送 确认报文段（ACK=1，确认号ack=u+1，seq=v，v是B已传送的最后一个字节的序号 + 1）；
> * B收到并发送后：CLOSE-WAIT（关闭等待）状态。此时还可以向A发送数据。
> * A收到后：FIN-WAIT-2（终止等待 2）状态。
> * 第三个：B向A发送 连接释放报文段（FIN=1，ACK=1，ack=u+1，seq=w，w为假定值）；
> * B发送后：LAST-ACK（最后确认）状态。
> * 第四个：A向B发送 确认报文段（ACK=1，ack=w+1，seq=u+1）；
> * A收到并发送后：TIME-WAIT（时间等待）状态。
> * A等待 2MSL（MSL叫最长报文段寿命）后：CLOSE（关闭）状态；B收到后：CLOSE（关闭）状态。
>   

**结束标志是：**当A撤销相应的**传输控制块TCB**后，就结束了这次的TCP连接。

<img :src="$withBase('/img/四报文挥手.png')" alt="four-way-handshake"/>

#### 为什么A在 TIME-WAIT状态 必须等待 2MSL的时间？

1. 为了保证 A发送的最后一个ACK报文段能够到达B；
2. 防止上一节提到的 “已失效的连接请求报文段” 出现在本连接中。



## TCP和UDP的区别

* TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立链接。
* TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。
* TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。
* TCP只能是1对1的，UDP支持1对1,1对多。
* TCP的首部较大为20字节，而UDP只有8字节。
* TCP是面向连接的可靠性传输，而UDP是不可靠的。

## http2.0

- 提升访问速度(可以对于,请求资源所需时间更少,访问速度更快,相比 http1.0)
- 允许多路复用:多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了:在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制(连接数量)，超过限制会被阻塞。
- 二进制分帧:HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码
- 首部压缩
- 服务器端推送
## fetch发送2次请求的原因

fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功。

> **204 No Content**：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。
>
> 对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑使用状态码204来作为返回信息，从而省掉多余的数据传输。

当发生跨域请求时，fetch会先发送一个OPTIONS请求，来确认服务器是否允许接受请求服务器同意后，才会发送真正的请求。

## cookie、sessionStorage、localStorage的区别

<img :src="$withBase('/img/Cookie_SessionStorage_LocalStorage.png')" alt="Cookie_SessionStorage_LocalStorage"/>

共同点 : 都是保存在浏览器端，并且是同源的。

- cookie：cookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递。而sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径(path)的概念，可以限制 cookie 只属于某个路径下，存储的大小很小只有 4K 左右。
- sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持。
- localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据。

localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。

cookie 的作用：

- 保存用户登录状态。例如将用户 id 存储于一个 cookie 内，这样当用户下次访问该页面时就不需要重新登录了。cookie 还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。
- 跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie 后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。
- 定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用 cookie 来记录用户的选项，例如:背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。
## 说一下 web worker
Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。

这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

Web Worker 有以下几个使用注意点。

（1）同源限制

分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

（2）DOM 限制

Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。

（3）通信联系

Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

（4）脚本限制

Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

（5）文件限制

Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。

## Doctype作用?严格模式与混杂模式如何区分？它们有何意义?

Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。

严格模式的排版和JS 运作模式是 以该浏览器支持的最高标准运行。

混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。

## Cookie如何防范XSS攻击

XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：

httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。

secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。



