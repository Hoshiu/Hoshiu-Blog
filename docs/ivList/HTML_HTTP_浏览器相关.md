# HTML/HTTP相关

## HTML语义化标签的优点

* 便于用户阅读，样式丢失的时候能让页面呈现清晰的结构
* 有利于SEO（搜索引擎优化），搜索引擎根据标签来确定上下人和各个关键字的权重，利于浏览器爬虫
* 方便其他设备解析，如盲人阅读器根据语义渲染网页
* 便于团队开发和维护，更具可读性

## http和https的区别

https的SSL加密是在传输层实现的。

(1)http和https的基本概念

http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。

### http和https的区别

* Https协议需要ca证书，费用较高。

* http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

* 使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443

* http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### https协议的工作原理

客户使用https url访问服务器，则要求web 服务器建立ssl链接。

web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。

客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。

客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。

web服务器通过自己的私钥解密出会话密钥。

web服务器通过会话密钥加密与客户端之间的通信。

### https协议的优点

使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

### https协议的缺点

https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。

https缓存不如http高效，会增加数据开销。

SSL证书也需要钱，功能越强大的证书费用越高。

SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。

##	TCP 三次握手，四次挥手

<img :src="$withBase('/img/三报文握手.png')" alt="three-way-handshake"/>

> 下面介绍三报文握手的过程，其中用 A 表示TCP客户程序，B表示TCP服务器程序。
>
> * 最开始，A、B：CLOSED（关闭）状态，A、B都创建传输控制块TCB。
> * 第一个：A向B发送 连接请求报文段（同步位SYN=1，不能携带数据，初始序号 seq=x）；
> * A发送后：SYN-SENT（同步已发送）状态；B：LISTEN（收听）状态。
> * 第二个：B向A发送 确认报文段（SYN=1，ACK=1，确认号ack=x+1，不能携带数据，初始序号 seq=y）；
>   B收到并发送后：SYN-RCVD（同步收到）状态。
> * 第三个：A向B发送 确认报文段（ACK=1，ack=y+1，序号seq=x+1，携带数据消耗序号，不携带不消耗）；
> * A收到并发送后：ESTAB-LISHED（已建立连接）状态。
> * B收到后：ESTAB-LISHED（已建立连接）状态。

#### 为什么A最后还要发送一次确认？

主要是为了防止**已失效的连接请求报文段**（A向B发送的第一个报文段延误到连接释放以后的某个时间）突然又传送到了B，让B误以为A又发出了一次新的连接请求，因而产生错误。



### 四报文挥手

TCP的连接释放又称为**四报文握手**，客户和服务器之间需要交换**四个 TCP 报文段**。

> * 最开始，A、B：ESTAB-LISHED（已建立连接）状态。
> * 第一个：A向B发送 连接释放报文段（终止控制位FIN=1，序号seq=u，u是A已传送的最后一个字节的序号 + 1）；
> * A发送后：FIN-WAIT-1（终止等待 1）状态。
> * 第二个：B向A发送 确认报文段（ACK=1，确认号ack=u+1，seq=v，v是B已传送的最后一个字节的序号 + 1）；
> * B收到并发送后：CLOSE-WAIT（关闭等待）状态。此时还可以向A发送数据。
> * A收到后：FIN-WAIT-2（终止等待 2）状态。
> * 第三个：B向A发送 连接释放报文段（FIN=1，ACK=1，ack=u+1，seq=w，w为假定值）；
> * B发送后：LAST-ACK（最后确认）状态。
> * 第四个：A向B发送 确认报文段（ACK=1，ack=w+1，seq=u+1）；
> * A收到并发送后：TIME-WAIT（时间等待）状态。
> * A等待 2MSL（MSL叫最长报文段寿命）后：CLOSE（关闭）状态；B收到后：CLOSE（关闭）状态。

**结束标志是：**当A撤销相应的**传输控制块TCB**后，就结束了这次的TCP连接。

<img :src="$withBase('/img/四报文挥手.png')" alt="four-way-handshake"/>

#### 为什么A在 TIME-WAIT状态 必须等待 2MSL的时间？

1. 为了保证 A发送的最后一个ACK报文段能够到达B；
2. 防止上一节提到的 “已失效的连接请求报文段” 出现在本连接中。



## TCP和UDP的区别

* TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立链接。
* TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。
* TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。
* TCP只能是1对1的，UDP支持1对1,1对多。
* TCP的首部较大为20字节，而UDP只有8字节。
* TCP是面向连接的可靠性传输，而UDP是不可靠的。

## WebSocket 的实现和应用

#### 什么是 WebSocket?

HTML5新增协议，它的目的在浏览器和服务器之间建立一个不受限的双向实时通信的通道。比如，服务器可以任意时刻发送消息给浏览器。它是基于TCP，先通过HTTP/HTTPS协议发起一条特殊的HTTP请求进行握手后创建一个用于交换数据的TCP连接。

Websocket 使用 ws 或 wss 的统一资源标志符。

#### **它的优势是什么?**

- 浏览器和服务器只要一次握手动作。
- 双方可以在任意时刻，相互推送消息。
- 服务器和浏览器之间交换的头信息很小。

#### **WebSocket与传统HTTP协议区别是什么?**

- HTTP协议，浏览器不主动请求，服务器没法发送数据给浏览器。
- HTTP协议每次链接都必须是三次握手才能发送消息，WebSocket只要一次就能发送消息。
- HTTP协议每次请求都要发送head，WebSocket一旦建立链接，之后请求就不要发送head。

HTTP可用轮询或comet机制实现WebSocket功能，但是有缺点。

**轮询**：js启动定时器，以固定时间间隔给服务器发送请求，询问服务器有没有新消息。

- 实时性不够
- 频繁请求給服务器造成很大压力

**comet**：请求没有超过预定时间或者没有返回数据，一直保持链接状态。等有数据，再推送。

- 线程挂起，浪费服务器资源
- 长时间没有数据，链路上任何一个网关都可能关闭这个链接。这要求comet连接必须定期发ping，检查连接是否正常。

#### **如何使用WebSocket?**

WebSocket链接必须由浏览器发起，虽然基于HTTP协议发展，但是和HTTP协议不一样。请求以ws://开头的地址，请求头申明这是WebSocket链接。服务器返回，表示成功建立WebSocket。

## 为什么CSS要放在头部，js要放在body底部

CSS放头部，JS放底部，这样可以提高页面的性能。

* CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。
* JS 阻塞 DOM 解析，但浏览器会"偷看"DOM，预先下载相关资源。
* 浏览器遇到 <script>且没有defer或async属性的 标签时，会触发页面渲染，因而如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。

## js设置为 async 和 defer 的区别

* `async` :并行加载，加载完成立即执行加载的资源，会打断DOM解析。
* `defer`:并行加载延迟执行，加载完成后等待DOM解析完成后执行加载的资源，不会打断DOM解析。
* 区别: `async`加载完成后会立即执行加载的资源，因此资源的执行顺序不可控，先加载完成的资源先执行;`defer`加载完成后会将加载的资源按照加载开始顺序放到队列中，等待DOM解析完成后依次执行，资源执行属性可控。

## http2.0

- 提升访问速度(可以对于,请求资源所需时间更少,访问速度更快,相比 http1.0)
- 允许多路复用:多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了:在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制(连接数量)，超过限制会被阻塞。
- 二进制分帧:HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码
- 首部压缩
- 服务器端推送
## fetch发送2次请求的原因

fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功。

> **204 No Content**：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。
>
> 对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑使用状态码204来作为返回信息，从而省掉多余的数据传输。

当发生跨域请求时，fetch会先发送一个OPTIONS请求，来确认服务器是否允许接受请求服务器同意后，才会发送真正的请求。

## 说一下 web worker
在HTML页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。

Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。

这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

Web Worker 有以下几个使用注意点。

（1）同源限制

分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

（2）DOM 限制

Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。

（3）通信联系

Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

（4）脚本限制

Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

（5）文件限制

Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。

## Doctype作用?严格模式与混杂模式如何区分？它们有何意义?

Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。

严格模式的排版和JS 运作模式是 以该浏览器支持的最高标准运行。

混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。



## GET 和 POST 的区别

- get 参数通过 url 传递，post 放在 request body 中。
- get 请求在 url 中传递的参数是有长度限制的，而 post 没有。
- get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。
- get 请求只能进行 url 编码，而 post 支持多种编码方式
- get 请求参数会被完整保留在浏览历史记录里,而 post 中的参数不会被保留。
- GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
- GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。

## Cookie如何防范XSS和CRSF攻击？防御方法？

**XSS（跨站脚本攻击）**是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：

httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。

secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。

**CSRF（Cross Site Request Forgery，跨站请求伪造）**，字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。

防御CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。

## cookie session区别

* cookie数据存放在客户的浏览器上，session数据放在服务器上。
* cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
  考虑到安全应当使用session。
* session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
  考虑到减轻服务器性能方面，应当使用COOKIE。
* 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

## cookie、sessionStorage、localStorage的区别

<img :src="$withBase('/img/Cookie_SessionStorage_LocalStorage.png')" alt="Cookie_SessionStorage_LocalStorage"/>

共同点 : 都是保存在浏览器端，并且是同源的。

- cookie：cookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递。而sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径(path)的概念，可以限制 cookie 只属于某个路径下，存储的大小很小只有 4K 左右。
- sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持。
- localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据。

localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。

cookie 的作用：

- 保存用户登录状态。例如将用户 id 存储于一个 cookie 内，这样当用户下次访问该页面时就不需要重新登录了。cookie 还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。
- 跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie 后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。
- 定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用 cookie 来记录用户的选项，例如:背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。

## 几个很实用的 BOM 属性对象方法?

Bom 是浏览器对象。

#### location 对象

- location.href-- 返回或设置当前文档的 URL
- location.search -- 返回 URL 中的查询字符串部分。例如 http://www.baidu.com?id=5&name=dreamdu 返回包括(?)后面的内容?id=5&name=dreamdu
- location.hash -- 返回 URL#后面的内容，如果没有#，返回空。
- location.host -- 返回 URL 中的域名部分，例如 www.dreamdu.com
- location.hostname -- 返回 URL 中的主域名部分，例如 dreamdu.com
- location.pathname -- 返回 URL 的域名后的部分。例如http://chenyilong369.github.io/webDesign/ 返回/webDesign/
- location.port -- 返回 URL 中的端口部分。例如 http://localhost:8080/xhtml/返回 8080
- location.protocol -- 返回 URL 中的协议部分。例如 http://localhost:8080/xhtml/ 返回(//)前面的内容 http:
- location.assign -- 设置当前文档的 URL
- location.replace() -- 设置当前文档的 URL，并且在 history 对象的地址列表中移除这个 URL
- location.replace(url);
- location.reload() -- 重载当前页面

#### history 对象

- history.go() -- 前进或后退指定的页面数 history.go(num);
- history.back() -- 后退一页
- history.forward() -- 前进一页

#### Navigator 对象

- navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)
- navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie

## 强，协商缓存

### 参考回答：

缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。



|          | 获取资源形式 | 状态码              | 发送请求到服务器                 |
| -------- | ------------ | ------------------- | -------------------------------- |
| 强缓存   | 从缓存取     | 200（from cache）   | 否，直接从缓存取                 |
| 协商缓存 | 从缓存取     | 304（not modified） | 是，通过服务器来告知缓存是否可用 |

强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。

协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match

详情已记在笔记中。

## HTML5新增的元素

首先html5为了更好的实践web语义化，增加了header，footer，nav,aside,section等语义化标签，在表单方面，为了增强表单，为input增加了color，emial,data ,range等类型，在存储方面，提供了sessionStorage，localStorage,和离线存储，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素audio和vedio，另外还有地理定位，canvas画布，拖放，多线程编程的web worker和websocket协议

## 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？

这是一个必考的面试问题，

输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录。

缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存

缓存中没有则查找系统的hosts文件中是否有记录，如果没有则：

* DNS 域名解析： 域名解析成ip地址
* 发起TCP连接： 三次握手 A）可以吗？ B）可以，确定吗？ A）确定，连接吧！
* 发送HTTP请求，接受HTTP响应：

​		HTTP请求报文格式：请求行+请求头+空行+消息体
​		HTTP响应报文格式：状态行+响应头+空行+消息体

断开TCP连接： 四次挥手 A）断开吧？ B）好，我稍微检查一下 B）可以了，断开吧，再见 A)好的，再见

渲染： 浏览器解析HTML代码，请求js，css等资源，将页面渲染出来

## 页面渲染流程

* 浏览器解析html源码，然后创建一个 DOM树。在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。

  **DOM树的根节点就是documentElement，对应的是html标签。**

* 浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。
  对CSS代码中非法的语法它会直接忽略掉。

* 解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html中的style。

  **DOM Tree + CSSOM --> 渲染树（rendering tree）。**

* 渲染树和DOM树有点像，但是是有区别的。DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。

  需要注意的是，渲染树(Render Tree)由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。

**三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。**

一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。



## click在ios上有300ms延迟，原因及如何解决？

产生延迟的原因是为了在小屏幕上浏览桌面端站点，采用了双击缩放的方式。

当用户点击一次屏幕后，浏览器不能立刻判断出用户确实要打开这个链接，还是想要进行双击操作。因此IOS Safari 就等待300ms，以判断用户是否再次点击了屏幕。

(1)粗暴型，禁用缩放

<meta name="viewport" content="width=device-width, user-scalable=no">


(2)利用FastClick，其原理是：

检测到touchend事件后，会通过DOM自定义事件立即触发模拟一个click事件，并且把浏览器300毫秒之后真正触发的事件给阻断掉。

**实质上，2014年chrome32已经解决该问题，只需定义viewport就不会存在此问题。**

<script src="./js/fastclick.js"></script>
<script>
    window.addEventListener( "load", function() {
        FastClick.attach( document.body );
    }, false );
</script>

## 前端优化

降低请求量: 合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。

加快请求速度: 预解析 DNS，减少域名数，并行加载，CDN 分发。

缓存: HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。

渲染: JS/CSS 优化，加载顺序，服务端渲染，pipeline。